### 对象进入老年代的情况
- 年龄达到设置的年龄，对象从S区转到老年代
- 对象过大，S区内存不足，直接进入老年代
- 动态年龄判断：系统遍历所有对象时，会按照年龄从小到大累积对象所占内存，如果超过了50%，会判断当前年龄和设置的年龄大小比较，如果当前年龄小，比当前年龄大的对象都会进入老年代，这个是为了防止年龄设置过大
导致对象还没有进入老年代，S区就满了触发Full GC，或者年龄设置过小导致的年轻的对象也进入了老年代

### 调优顺序
- 确定目标，确定系统的需求，判断GC对于系统性能的影响
- 优化，通过GC日志，结合系统需求，确定优化方案
- 验收优化结果，测试调优后的性能差异


### 案例一：Major GC 和 Manor GC频繁
#### 场景：Menor GC 一分钟100次，Major GC 4分钟一次，单次 Manor GC 25mm，单次Major GC 200mm，接口响应 50mm，通过计算得到将近10%的请求受到影响
#### 解决方式：
- 查看GC日志，优化Menor GC频繁问题，调大年轻代的内存大小，减少内存满了时间，减少GC频率
- 确定每次GC时间是否没有变大，如果年轻代每次GC存活对象不多的话，GC时间不会变大，因为复制的过程是相对耗时的
- 确定老年代GC时间，因为年轻代GC频率降低，有些存活时间短的对象不会进入老年代，老年代GC时间会变短

### 案例二： 请求高峰发生GC，导致性能下降
#### 解决方式：
- 通过GC日志判断问题，发现是cms在remark阶段时间过长，达到了1.36s，因为这个阶段是STW的所以导致响应时间变长
- remark阶段是重新标记阶段，是为了防止并发标记时候的漏标，而且因为有年轻代到老年代的引用，所以每次remark阶段都会扫描整个年轻代，cms本身提供了可中断的并发预清理，在年轻代超过2m时候开启，等到
Manor GC的时候会把没有引用的对象回收，如果一定时间内没有等到Manor GC，就会终止此状态，进入remark
- 通过日志可以看到remark慢就是因为年轻代没有GC导致的查询的对象变多导致的，所以可以通过参数指定remark前一直执行一次Manor GC，减少remark阶段遍历的对象，减少STW时间
