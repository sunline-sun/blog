### 内存划分
- 线程私有的
   - 程序计数器
   - 虚拟机栈
   - 本地方法栈
- 线程共享的
   - 堆
   - 方法区
   - 直接内存

### 程序计数器
- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
- 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

### Java虚拟机栈
- Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。
- 局部变量表主要存放了编译器可，知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用
- Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。

### 本地方法栈
- 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 

### 堆
- 此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。
- 在 JDK 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。

### 方法区
- 方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

### 运行时常量池
- 

### 直接内存
- Java堆和本地堆都可以操作的内存区域，可以避免两边复制数据，提高性能。

### 创建对象的过程
- 类加载检查
- 分配内存，分配方式由垃圾回收算法决定，就是查看是否有完整的内存区域用来分配
   - 指针碰撞，标记压缩，复制算法
   - 空闲列表，标记清除
- 初始化零值，保证不赋值可以直接使用
- 设置对象头，比如锁信息、GC信息、哈希码、指针信息等
- 执行init方法

##### 内存分配并发问题（补充内容，需要掌握）
- CAS+失败重试： CAS 是乐观锁的一种实现方式。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。
- TLAB： 为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配

### 对象的内存布局
- 对象头
  - 存储对象自身的自身运行时数据（哈希码、GC分代年龄、锁状态标志等等）
  - 类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。 
- 实例数据
- 对齐填充，占位用，因为对象大小必须是8的整倍数

### 对象的访问定位
- 使用句柄，会在堆中分配一个区域作为句柄池，栈中的指针就指向句柄地址，句柄中包含对象实例地址（堆）和对象类型数据（方法区）
- 直接指针，直接访问实例地址，但是必须考虑对象类型数据的存放
#### 两种访问定位的区别
- 使用句柄方式比较稳定，存放的是固定的句柄地址，对象移动了也是改句柄中的实例指针
- 使用直接指针比较快，少了一次指针访问

### String创建的两种方式
- String a = "a";这种方式直接使用常量池的数据
- String a = new String("a"); 这种方式创建一个对象
- String a = "a" + "b";也是直接使用常量池中的数据
- String a = new String("a");这种会创建两个对象，一个放在常量池，一个放在堆里

### 








