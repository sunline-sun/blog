### 分库分表：
- 垂直切分：将原有的订单库分为订单基础库和订单流程库，缓解了单集群的压力
- 水平切分：
  - 切片策略：
    - 查询切片 将id和库的mapping映射关系记录在单独的表里
    - 优点：算法可以随时修改
    - 缺点：引入额外的单点
  - 范围切片 根据时间区间划分
    - 优点：大小可控，天然水平扩展
    - 缺点：无法解决集中写入的问题
  - Hash切片 一般采用mod切分，推荐使用mod 2^n 这种一致性hash
    - 比如可以根据userid后四位mod 32分到32个库，在把userid后四位div 32 mod 32 分到32个表，一共32*32 = 1024个表，分为8个集群，每个集群4个库
    - 优点：方便水平扩展
    - 比如：
      - 场景一：数据性能达到瓶颈
        - 方法一：直接扩展到32个集群
        - 方法二：将分库分表规则改为32 * 2^n * 32/2^n ,最多可以达到1024个集群
      - 场景二：单表容量达到瓶颈
        - 方法：可以分库规则不变，库里的表在进行分裂
### 唯一ID方案：
- 数据库自增
  - 优点：简单 
  - 缺点： 单点风险
- 数据库集群并设置响应的步长
  - 优点：高可用
  - 缺点：需要单独的数据库集群
- snowFlake Twitter
  - 优点：高性能，高可用，易扩展
  - 缺点：需要独立的集群以及ZK
- GUID、Random算法
  - 优点：简单
  - 缺点：ID较长，有重复几率
- 实践方案：时间戳+用户标识+随机数
### 事务支持：支持聚合体的事务
### 复杂查询：垂直切分后，就和join说拜拜了，查询条件一定在切分的维度下，没有的话就建立映射关系
### 数据迁移：（中途开始水平拆分）
- 数据库双写，查询走老模型 ，通过job导历史数据，数据对账，补齐差异
- 历史数据导入完成且数据对账无误，数据库依旧双写，但是事务成功与否以新模型为主，现在查询切到新模型，每日job数据对账
- 老模型不在同步写入，仅当订单有终态时才会异步补上，此时只有离线数据依赖老模型，对账改造完全之后彻底废弃老模型

