## mysql
### inndb数据存储结构-b+树
- B+树是一个N叉树的树形结构，一个节点下可以有N个节点，N的大小取决于数据块的大小，也就是innodb中的页。B+树只有最后一层会存储行里的所有数据，其他层只存ID，并且底层是个链表结构，可以方便范围查询。以整形字段为例，一个页可以存储1200个数据，4层也就是可以存储1200的3次方的数据，当然因为最后一层除了存储ID还存储了整行的数据，但是一个4层架构也可以存几亿的数据


### 为什么用b+树不用b树
- 哈希表不可以，因为有哈希冲突，并且占用内存，并且不适合范围查询，适用于等值查询场景，如memcached以及其他一些nosql引擎，但是mysql memory存储引擎用的hash索引
- 数组链表不可以，因为数组插入慢，链表查询慢，适用于静态存储
- 二叉树不可以，因为每个节点存储数据少，分支少，导致树的深度过高，复杂度变高
- B树不可以，因为B树节点除了key值还会存数据，导致每个磁盘块数据量少，导致树深度变高，增加io次数
- B+树可以，因为B+树只有末级叶子节点存储数据，其他只存key，树深度很低，而且末级叶子节点是个链表结构，所以支持两种查询方式，树查询和链表查询

### 如何提升sql查询性能 
- group by优化
  - 如果对 group by 语句的结果没有排序要求，要在语句后面加 order by null
  - 尽量让 group by 过程用上表的索引，确认方法是 explain 结果里没有 Using temporary 和 Using filesort
  - 如果 group by 需要统计的数据量不大，尽量只使用内存临时表
  - 也可以通过适当调大 tmp_table_size 参数，来避免用到磁盘临时表
  - 如果数据量实在太大，使用 SQL_BIG_RESULT 这个提示，来告诉优化器直接使用排序算法得到 group by 的结果
- join优化
  - 这种关联查询尽量先把每个关联的表过滤成小表，减少关联次数
  - join建议使用BKA算法，使用方式就是给被驱动表关联字段加上索引
  - join的时候最好小表放在前面当做驱动表
- 对索引字段最好不要做函数操作，因为可能会破坏索引的有序性，优化器可能会放弃走索引
- 对索引字段最好不要有类型转换，也会导致不走索引
- 最好不要使用select '*' from ,而是查询具体的列
- 尽量使用到覆盖索引，避免回表查询
- 使用betwwen and代替in
- 创建合适的索引
- like的时候最好不要左边也like，如like（%1%）


### 慢查询分析与优化-explain，可以了解详细点
- 导致慢查询的原因
  - 索引没有设计好
  - mysql选错了索引（因为mysql优化器的逻辑：扫描行数、是否回写、是否用临时表、是否排序等，出现选错索引就是因为判断扫描行数的时候统计错了（删除历史数据后再插入）和判断需要回写了，比如select * from t where a between 5000 and 10000,会选全表查询），这时候可以用force index强制走索引，或者analze table t重新统计信息
- explain，执行计划，可以通过这个判断sql的执行情况
  - id，sql执行的顺序，ID越大越先执行，如果id一致，按照从上到下的顺序执行的
  - select type，就是查询类型，包括
    - simple，最简单的查询，不包含子查询和union
    - primary，对于有子查询的最外层的select就是primary类型
    - union，union语句中后面的查询
    - DEPENDENT UNION，一般是子查询中第二个查询
    - UNION RESULT，union的结果
    - SUBQUERY，子查询第一个select
  - table，表示查询的是哪个表的，有时候也会是虚拟表，虚拟表最后一位是数字，代表id是多少的查询
  - type，表示是否用了索引，重点优化字段
    - system，const的特殊情况。比如select * from (select id from a where b = 1),里面子查询只有一条数据，外面的就是system类型 
    - const，表示只有一个匹配行，通过索引一次就能找到，一般就是主键或者唯一索引的查询
    - eq_reg，表示表中只有一条记录与之匹配，一般是关联查询的时候，关联条件的字段是主键或者唯一索引
    - ref，就是普通索引的查询
    - range，检索给定范围的查询，一般就是大于小于between这种查询
    - index，遍历索引树，比ALL快点，因为索引文件没有数据文件大
    - ALL，全表扫描
  - possible_keys，表示可能用到的索引，不一定真实使用了
  - key，实际用到的索引
  - key_len，表示索引使用的字节数，可以计算用到的索引长度
  - ref，表示哪一列被使用了
  - rows，查询大致需要扫描的行数
  - filter，表示选取的行和读取的行的百分比，100表示选取了100%，80表示读取了80%。
  - extra，一些额外的信息，也是优化的时候注意的地方
    - Using filesort，使用外部的索引排序，不是用的表内的索引排序，一般需要优化
    - Using temporary，是否使用了临时表，一般出现在order by 和group by 里，最好优化
    - Using index，表示用到了覆盖索引
    - Using where，使用了where过滤
    - Using join buffer，使用了join 缓存

### 数据库表锁机制
#### 按锁粒度划分
- myisam只支持表锁，innodb支持表锁和行锁
- 全局锁
  - 对整个数据库实例加锁，加锁后整个数据库内的更新等操作都会阻塞。
  - 应用场景是用于全库逻辑备份的时候。
  - 风险就是全局锁下所有业务都停了，主从同步也会延迟
- 表级锁
  - 表锁，粒度较大，会锁住整张表，特点是开销小，锁表块，但是容易出现锁冲突。
  - MDL锁，MDL锁是防止DDL和DML之间冲突的锁，DDL加写锁，DML加读锁，读读不冲突，读写、写写互斥
- 行锁
  - 粒度小，更新操作会对影响到的行加行锁，并且会在事务提交后才释放，可以减少锁冲突，会出现死锁，所以实际用的时候最好把可能会存在锁冲突的表放在后面操作
  - RR隔离级别下，如果条件列是索引列，锁住的是索引记录，没有索引的话会锁整个表
- innodb下锁的算法有3种，next-key lock（就是间隙锁加记录锁）、间隙锁、记录锁，
  - next-key lock是锁的基本单位，但是对于不同情况的查询有优化机制
  - 间隙锁是为了防止幻读
  - 如果是唯一索引下的等值查询，退化为记录锁
  - 如果普通索引下的等值查询，退化为间隙锁
 
#### 按锁类别划分
- 共享锁，查询操作加共享锁
- 排它锁，更新操作加排它锁
- 共享锁下，只可以加共享锁，排它锁下什么锁都不能加，为了保证读写安全

### 什么时候会锁表，如何避免 
- RR隔离级别下，update如果条件列没有索引，会退化为表锁
- 锁表情况下容易造成锁冲突

- 避免方式
 - 尽量避免大事务，避免锁冲突
 - 尽量使用索引，行锁影响比表锁要小
 - 访问表的顺序最好一致，避免死锁

### 大数据量插入，如何避免锁表-可以采用批量插入？

### sql优化器是如何优化的
- 主要作用就是对sql进行优化，比如判断用哪个索引，多表关联的时候，决定每个表的链接顺序
- 优化过程会判断扫描行数、是否回写、是否用临时表、是否排序等多个维度进行判断

### 聚簇索引，索引下推，回表，覆盖索引，最左匹配



## jvm

### 内存模型 
- 线程私有的
   - 程序计数器
   - 虚拟机栈
   - 本地方法栈
- 线程共享的
   - 堆
   - 方法区
   - 直接内存

### jvm垃圾回收算法及使用场景
- 标记清除
- 标记复制 - 新生代
- 标记整理 - 老年代

### 垃圾回收器有哪些（一般用cms和g1）
- 新生代
  - Serial
  - ParNew
  - Parallel Scavenge
- 老年代
  - Serial Old
  - Parallel Old
  - CMS
- 整个堆的
  - G1

### jvm线上配置，如何调优 
- 调优工具
  - jconsole
  - jvisualvm
- 调优参数
  - -Xms2g：初始化推大小为 2g；
  - -Xmx2g：堆最大内存为 2g；
  - -XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；
  - -XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；
  - –XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；
  - -XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合
  - -XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；
  - -XX:+PrintGC：开启打印 gc 信息；
  - -XX:+PrintGCDetails：打印 gc 详细信息。


### 线上应用内存溢出后怎么办，dump gc文件后如何分析
- 

## java基础 

### hashmap原理（1.7和1.8）
- 结构
- 构造方法
- 变量：容量、负载因子、阈值
- 查询
- 插入
- 扩容

### currenthashmap原理 
- 加锁方式（1.7和1.8区别）
- 数据结构
- 并发下初始化
- 怎么保证线程安全的
- 扩容
- 如果保证读和扩容并发
- 对于红黑树来说，读和写可以并行么？
- 插入
- 查询

### jdk并发包 有哪些类，重点讲下，实现原理
- AQS
  - acquire()方法
  - conditionObject内部类
  - 模板模式
  - 两种锁模式（独占、共享）
  - CountDownLatch
- RennTranck
  - lock()
  - unlock()
- BlockingQueue
  - ArrayBlockingQueue
  - LinkedBlockingQueue
  - SynchronousQueue
  - PriorityBlockingQueue
- 线程池  

### syncnizenizd锁升级
- 偏向锁
- 轻量级锁
- 重量级锁

## redis

### redis常见数据结构 
- string
- hash
- list
- set
- zset

### redis5新特性-例如：redis用集群用slot，而不是哨兵机制了?
- Stream数据结构
- 

### redis穿透、雪崩及解决方案
- 布隆过滤器
- 设置null
- 设置过期时间加随机数，保证不再同一时间过期

### redis使用规范 

### redis 大key如何处理 
- memory usage 发现
- 如果可以拆分就拆分
- 如果导致阻塞，可以用lazyfree异步删除，减少阻塞

### 如何实现分布式锁，有哪几种方案，有开源实现吗（有，目前流行的有redission）
- 数据库层（主键id）
- redis
- zookeeper
- redission

## mq

### 目前mq用什么框架-rocketmq

### 实现机制（生产者、服务broker、消费者、topic、group...）

### broker如何实现存储的 

### mq为什么很快，采用pagecache和顺序写 

### 如何实现消息幂等 

### 消息如何不丢失 -从生产端、broker、消费端分析

### 事务消息如何实现 

### 延时消息如何实现

### 消息积压了怎么办

## 分布式服务框架

### CAP
- 一致性，保证从哪个节点读到的都是最新的数据
- 可用性，集群下一部分节点故障，依旧可以提供服务
- 分区容错性，不同分区之间连接断开，依旧可以对外提供服务，这个是一定要保证的
- Zookeeper是CP，Eureka是AP

### Base
- Base是对CAP权衡的结果，要求达到下面3个状态
- 基本可用，允许响应时间增长一些，或者并发太大下可以服务降级，保证服务的可用性
- 软状态，指允许系统中的数据存在中间状态，并且这个状态不会影响系统的可用性，也就是不同节点之间的数据同步允许有延迟
- 最终一致性，要求可以没有强一致性，但是需要保证最终一致性

## springcloud和dubbo
- dubbo的关注点是服务的调用、服务分发、服务治理、流量监控和熔断，底层是基于netty这样的NIO框架，基于TCP协议传输的RPC框架
- springcloud关注点是整个微服务生态，服务调用是基于HTTP协议的rest请求，比RPC请求更灵活

### RPC调用

### dubbo架构核心
- Container： 服务运行容器，负责加载、运行服务提供者。必须。
- Provider： 暴露服务的服务提供方，会向注册中心注册自己提供的服务。必须。
- Consumer： 调用远程服务的服务消费方，会向注册中心订阅自己所需的服务。必须。
- Registry： 服务注册与发现的注册中心。注册中心会返回服务提供者地址列表给消费者。非必须。
- Monitor： 统计服务的调用次数和调用时间的监控中心。服务消费者和提供者会定时发送统计数据到监控中心。 非必须。

### dubbo原理
- config 配置层：Dubbo相关的配置。支持代码配置，同时也支持基于 Spring 来做配置，以 ServiceConfig, ReferenceConfig 为中心
- proxy 服务代理层：调用远程方法像调用本地的方法一样简单的一个关键，真实调用过程依赖代理类，以 ServiceProxy 为中心。
- registry 注册中心层：封装服务地址的注册与发现。
- cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心。
- monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心。
- protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心。
- exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心。
- transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心。
- serialize 数据序列化层 ：对需要在网络传输的数据进行序列化。

### dubbo spi是什么 
SPI（Service Provider Interface） 机制被大量用在开源项目中，它可以帮助我们动态寻找服务/功能（比如负载均衡策略）的实现。
SPI 的具体原理是这样的：我们将接口的实现类放在配置文件中，我们在程序运行过程中读取配置文件，通过反射加载实现类。这样，我们可以在运行的时候，动态替换接口的实现类。和 IoC 的解耦思想是类似的。
Java 本身就提供了 SPI 机制的实现。不过，Dubbo 没有直接用，而是对 Java原生的 SPI机制进行了增强，以便更好满足自己的需求。
JDK SPI：
JDK 标准的 SPI 会一次性加载所有的扩展实现，如果有的扩展很耗时，但也没用上，很浪费资源。所以只希望加载某个的实现，就不现实了
DUBBO SPI：
1、对 Dubbo 进行扩展，不需要改动 Dubbo 的源码
2、延迟加载，可以一次只加载自己想要加载的扩展实现。
3、增加了对扩展点 IOC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。
4、Dubbo 的扩展机制能很好的支持第三方 IoC 容器，默认支持 Spring Bean。


### dubbo协议
- dubbo支持很多协议，官方推荐使用dubbo协议
- Dubbo： 单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步 Hessian 序列化。Dubbo推荐使用dubbo协议。
- RMI： 采用 JDK 标准的 RMI 协议实现，传输参数和返回参数对象需要实现Serializable 接口，使用 Java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。 多个短连接 TCP 协议传输，同步传输，适用常规的远程服务调用和 RMI 互操作。在依赖低版本的Common-Collections 包，Java 序列化存在安全漏洞。
- WebService：基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用。
- HTTP： 基于 Http 表单提交的远程调用协议，使用 Spring 的 HttpInvoke 实现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器 JS 调用。
- Hessian：集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务， Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输，Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件。
- Memcache：基于 Memcache实现的 RPC 协议。Redis：基于 Redis 实现的RPC协议。


### dubbo负载均衡策略
- 随机选取
- 轮询
- 最少活跃
- 一致性hash策略

### dubbo遇到哪些坑 

### 如何解决分布式事务，有哪些方案（比如（tcc、事务消息+补偿）
- 2PC
- 3PC
- TCC

## 如何实现秒杀方案？

## zk和nacos实现原理，遇到的一些坑

## 大数据量和高并发如何优化及方案-比如服务化、分库分表

## 如何限流降级-比如接入sentinel框架、常用的限流算法及详细

## 数据库和缓存一致性如何解决，方案
