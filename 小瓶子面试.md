## mysql
### inndb数据存储结构-b+树
- B+树是一个N叉树的树形结构，一个节点下可以有N个节点，N的大小取决于数据块的大小，也就是innodb中的页。B+树只有最后一层会存储行里的所有数据，其他层只存ID，并且底层是个链表结构，可以方便范围查询。以整形字段为例，一个页可以存储1200个数据，4层也就是可以存储1200的3次方的数据，当然因为最后一层除了存储ID还存储了整行的数据，但是一个4层架构也可以存几亿的数据


### 为什么用b+树不用b树
- 哈希表不可以，因为有哈希冲突，并且占用内存，并且不适合范围查询，适用于等值查询场景，如memcached以及其他一些nosql引擎，但是mysql memory存储引擎用的hash索引
- 数组链表不可以，因为数组插入慢，链表查询慢，适用于静态存储
- 二叉树不可以，因为每个节点存储数据少，分支少，导致树的深度过高，复杂度变高
- B树不可以，因为B树节点除了key值还会存数据，导致每个磁盘块数据量少，导致树深度变高，增加io次数
- B+树可以，因为B+树只有末级叶子节点存储数据，其他只存key，树深度很低，而且末级叶子节点是个链表结构，所以支持两种查询方式，树查询和链表查询

### 如何提升sql查询性能 
- group by优化
  - 如果对 group by 语句的结果没有排序要求，要在语句后面加 order by null
  - 尽量让 group by 过程用上表的索引，确认方法是 explain 结果里没有 Using temporary 和 Using filesort
  - 如果 group by 需要统计的数据量不大，尽量只使用内存临时表
  - 也可以通过适当调大 tmp_table_size 参数，来避免用到磁盘临时表
  - 如果数据量实在太大，使用 SQL_BIG_RESULT 这个提示，来告诉优化器直接使用排序算法得到 group by 的结果
- join优化
  - 这种关联查询尽量先把每个关联的表过滤成小表，减少关联次数
  - join建议使用BKA算法，使用方式就是给被驱动表关联字段加上索引
  - join的时候最好小表放在前面当做驱动表
- 对索引字段最好不要做函数操作，因为可能会破坏索引的有序性，优化器可能会放弃走索引
- 对索引字段最好不要有类型转换，也会导致不走索引
- 最好不要使用select '*' from ,而是查询具体的列
- 尽量使用到覆盖索引，避免回表查询
- 使用betwwen and代替in
- 创建合适的索引
- like的时候最好不要左边也like，如like（%1%）


### 慢查询分析与优化-explain，可以了解详细点
- 导致慢查询的原因
  - 索引没有设计好
  - mysql选错了索引（因为mysql优化器的逻辑：扫描行数、是否回写、是否用临时表、是否排序等，出现选错索引就是因为判断扫描行数的时候统计错了（删除历史数据后再插入）和判断需要回写了，比如select * from t where a between 5000 and 10000,会选全表查询），这时候可以用force index强制走索引，或者analze table t重新统计信息
- explain，执行计划，可以通过这个判断sql的执行情况
  - id，sql执行的顺序，ID越大越先执行，如果id一致，按照从上到下的顺序执行的
  - select type，就是查询类型，包括
    - simple，最简单的查询，不包含子查询和union
    - primary，对于有子查询的最外层的select就是primary类型
    - union，union语句中后面的查询
    - DEPENDENT UNION，一般是子查询中第二个查询
    - UNION RESULT，union的结果
    - SUBQUERY，子查询第一个select
  - table，表示查询的是哪个表的，有时候也会是虚拟表，虚拟表最后一位是数字，代表id是多少的查询
  - type，表示是否用了索引，重点优化字段
    - system，const的特殊情况。比如select * from (select id from a where b = 1),里面子查询只有一条数据，外面的就是system类型 
    - const，表示只有一个匹配行，通过索引一次就能找到，一般就是主键或者唯一索引的查询
    - eq_reg，表示表中只有一条记录与之匹配，一般是关联查询的时候，关联条件的字段是主键或者唯一索引
    - ref，就是普通索引的查询
    - range，检索给定范围的查询，一般就是大于小于between这种查询
    - index，遍历索引树，比ALL快点，因为索引文件没有数据文件大
    - ALL，全表扫描
  - possible_keys，表示可能用到的索引，不一定真实使用了
  - key，实际用到的索引
  - key_len，表示索引使用的字节数，可以计算用到的索引长度
  - ref，表示哪一列被使用了
  - rows，查询大致需要扫描的行数
  - filter，表示选取的行和读取的行的百分比，100表示选取了100%，80表示读取了80%。
  - extra，一些额外的信息，也是优化的时候注意的地方
    - Using filesort，使用外部的索引排序，不是用的表内的索引排序，一般需要优化
    - Using temporary，是否使用了临时表，一般出现在order by 和group by 里，最好优化
    - Using index，表示用到了覆盖索引
    - Using where，使用了where过滤
    - Using join buffer，使用了join 缓存

### 数据库表锁机制
#### 按锁粒度划分
- myisam只支持表锁，innodb支持表锁和行锁
- 全局锁
  - 对整个数据库实例加锁，加锁后整个数据库内的更新等操作都会阻塞。
  - 应用场景是用于全库逻辑备份的时候。
  - 风险就是全局锁下所有业务都停了，主从同步也会延迟
- 表级锁
  - 表锁，粒度较大，会锁住整张表，特点是开销小，锁表块，但是容易出现锁冲突。
  - MDL锁，MDL锁是防止DDL和DML之间冲突的锁，DDL加写锁，DML加读锁，读读不冲突，读写、写写互斥
- 行锁
  - 粒度小，更新操作会对影响到的行加行锁，并且会在事务提交后才释放，可以减少锁冲突，会出现死锁，所以实际用的时候最好把可能会存在锁冲突的表放在后面操作
  - RR隔离级别下，如果条件列是索引列，锁住的是索引记录，没有索引的话会锁整个表
- innodb下锁的算法有3种，next-key lock（就是间隙锁加记录锁）、间隙锁、记录锁，
  - next-key lock是锁的基本单位，但是对于不同情况的查询有优化机制
  - 间隙锁是为了防止幻读
  - 如果是唯一索引下的等值查询，退化为记录锁
  - 如果普通索引下的等值查询，退化为间隙锁
 
#### 按锁类别划分
- 共享锁，查询操作加共享锁
- 排它锁，更新操作加排它锁
- 共享锁下，只可以加共享锁，排它锁下什么锁都不能加，为了保证读写安全

### 什么时候会锁表，如何避免 
- RR隔离级别下，update如果条件列没有索引，会退化为表锁
- 锁表情况下容易造成锁冲突

- 避免方式
 - 尽量避免大事务，避免锁冲突
 - 尽量使用索引，行锁影响比表锁要小
 - 访问表的顺序最好一致，避免死锁

### 大数据量插入，如何避免锁表-可以采用批量插入？

### sql优化器是如何优化的
- 主要作用就是对sql进行优化，比如判断用哪个索引，多表关联的时候，决定每个表的链接顺序
- 优化过程会判断扫描行数、是否回写、是否用临时表、是否排序等多个维度进行判断

### 聚簇索引，索引下推，回表，覆盖索引，最左匹配



## jvm

### 内存模型 

### jvm垃圾回收算法及使用场景

### 垃圾回收器有哪些（一般用cms和g1）

### jvm线上配置，如何调优 

### 线上应用内存溢出后怎么办，dump gc文件后如何分析

## java基础 

### hashmap原理（1.7和1.8）

### currenthashmap原理 

### jdk并发包 有哪些类，重点讲下，实现原理

### syncnizenizd锁升级

## redis：

### redis常见数据结构 

### redis5新特性-例如：redis用集群用slot，而不是哨兵机制了

### redis穿透、雪崩及解决方案 

### redis使用规范 

### redis 大key如何处理 

### 如何实现分布式锁，有哪几种方案，有开源实现吗（有，目前流行的有redission）

## mq

### 目前mq用什么框架-rocketmq

### 实现机制（生产者、服务broker、消费者、topic、group...）

### broker如何实现存储的 

### mq为什么很快，采用pagecache和顺序写 

### 如何实现消息幂等 

### 消息如何不丢失 -从生产端、broker、消费端分析

### 事务消息如何实现 

### 延时消息如何实现

### 消息积压了怎么办

## 分布式服务框架

### springcloud和dubbo

### dubbo原理 

### dubbo spi是什么 

### dubbo协议

### dubbo遇到哪些坑 

### 如何解决分布式事务，有哪些方案（比如（tcc、事务消息+补偿）

## 如何实现秒杀方案？

## zk和nacos实现原理，遇到的一些坑

## 大数据量和高并发如何优化及方案-比如服务化、分库分表

## 如何限流降级-比如接入sentinel框架、常用的限流算法及详细

## 数据库和缓存一致性如何解决，方案
