# 并发
## Hashmap
### hash概念，有什么问题（hash冲突），怎么避免hash冲突
### hashmap底层数据结构是什么，数组+链表+红黑树，Node节点存储
### hashmap初始容量和负载因子大小
### 散列表什么时候创建的，new的时候还是put的时候
### 负载因子作用
### 什么时候转红黑树，超过8并且数组大小超过64，否则先扩容
### hashmap用的是默认的hash算法么，为什么要自定义
### hashmap长度为什么是2的幂次方
### put流程
### 红黑树写入流程，怎么找到父节点
### 红黑树原则
### 引入红黑树的原因
### 什么时候会触发扩容，扩容流程

## LinkedHashMap


## currentHashMap
### Node节点的hash为什么一般不小于0？
- 因为负值都有含义 1、扩容迁移数据的时候旧数据每个桶迁移完会放一个标记节点，这个节点hash是-1, 2、红黑树由一个代理节点表示，TreeBin，这个代理节点hash是-2
### currentHashMap并发下如何初始化的？
- 通过sizeCTL变量，多线程下会CAS操作CTL变量，如果等于-1，代表有线程在初始化，自旋获取状态为0的时候才可以插入数据， 如果0,，CAS修改为-1，如果CTL大于0，代表下次扩容的阈值，如果是负数小于-1，代表正在扩容，高16位是扩容标识，低16位代表正在参与扩容的线程数+1
### 扩容标识戳计算逻辑 ：
- 把老表size转为二进制，判断从高位开始到有1为止有多少个0，然后把0的个数转成二进制，和1000000一个16位的做或运算，就是扩容标识戳，第一高位代表负数
### currentHashMap 是怎么保证线程安全的？
- 如果这个桶的值是空的，CAS插入节点，如果桶有值，对这个头节点加sychounized锁
### currentHashMap是怎么统计数据量的
- 使用LongAdder，为什么不用AtomicLong，因为AtomicLong在多线程下效果并不好，底层还是串行的，但是LongAdder采用的是分段CAS，他会创建一个数组，多线程下会对数组里的不同对象进行CAS操作，最后会使用sum函数合并，效率比AtomicLong高。
### currentHashMap扩容的准备工作： 
- CAS操作sizeCTL变量为-2，代表当前有个线程在执行扩容逻辑 
- 创建一个新数组，并修改map的nexttable字段指向这个新数组
- 保存老表的长度到tranferindex变量，代表迁移进度，
- 迁移是从高位开始，到数组为0结束，迁移过的桶会加一个forwardingNode节点标识这个桶已经迁移过了
### currentHashMap中forwardingNode节点的作用
- 可以标识这个桶已经迁移过了
- 有一个变量指向这个数据对应新桶的位置，保证扩容和读线程的并发
### currentHashMap是怎么保证读和扩容并发的？ 通过forwardingNode
### currentHashMap是怎么处理扩容的时候的put请求的
- 如果put请求需要插入的桶是未被迁移的，直接获取桶的锁然后插入就行了
- 如果put请求需要插入的桶是被迁移的，这时候证明有其他的线程在扩容，这时候就帮助其他的线程先进行扩容逻辑，会通过forwardingIndex分配给他需要协助扩容的位置，扩容结束后直接再新数组中put操作
### 扩容工作线程是怎么维护sizeCTL低16位的线程数的
- 当有一个线程要帮助执行扩容操作时，都会把sizeCTL低16位加一
- 当有线程分配不到扩容任务区间的时候会退出扩容逻辑，sizeCTL减一
### 怎么判断一个线程是扩容中的最后一个线程
- 通过sizeCTL低16位判断，如果低16位-1=1的时候，就说明自身是最后一个线程了
### 扩容的最后一个线程需要做什么操作
- 判断老表中是否还有桶里节点不是forwardingNode的，有的话，迁移到新表
- 把新表的地址记录到map.table 中
- 计算新的扩容阈值
###  如果一个桶上是红黑树结构，这时候对于红黑树的读写可以并行么
- 不可以，因为写红黑树会造成树的重建，所以不可以读写并行
### 对于红黑树读写并行，currentHashMap是怎么解决的
- 红黑树节点中维护了一个状态state，如果读线程进来，判断state是否为1，是1的话代表有写线程在写，这时候会用红黑树节点内部维护的next属性进行链表查询，保证写操作不影响读操作，如果不是1，代表没有写锁，会把state+4，读线程结束会state-4
- 如果写线程进来，如果此时state是0，会设置为1，代表加了写锁
- 如果写进程进来，如果此时state不为0，代表有读进程，这时候会把第二位设置为1（这也是读进程为什么每次对state+-4），然后挂起自身线程
- 读进程读完数据后会判断state是否等于2，如果是2，代表有个写线程等待，唤醒写线程。







为什么redis的单线程模式这么快?
Redis单线程处理IO请求性能瓶颈？
多路复用的实现逻辑
aof先执行语句还是先写日志，有什么优缺点
aof有几种回写策略
aof重写机制的作用和原理
rdb会阻塞主进程么
持久化一般选择哪种方案
主从之前是怎么同步数据的
