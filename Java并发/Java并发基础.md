### 程序计数器为什么是私有的
- 字节码解释器通过修改程序计数器，实现代码的流程控制
- 多线程下，程序计数器记录了当前线程的执行位置，这样切换线程的时候才能知道当前线程执行到哪里了

### 虚拟机栈和本地方法栈为什么是私有的
- 因为他们存储的是局部变量表，操作数栈等，需要不被其他线程访问到

### 为什么使用多线程？多线程带来的问题
- 为了尽可能的发挥cpu和IO设备的效率。
- 问题：线程不安全，内存泄露，死锁

### 线程的几个状态
- new,线程刚被创建
- running,调用start()方法，并获得CPU资源 
- bloked, 调用同步代码后没有获取到锁进入阻塞状态
- waiting,执行wait()方法后
- timie_waiting,调用sleep等方法超过时间进入此状态
- terminated ，执行runnable的run()方法后
- https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java线程的状态.png![image](https://user-images.githubusercontent.com/55612309/110240725-36680a80-7f88-11eb-8f05-7597521d4973.png)

### 什么是上下文切换
- cpu为每个线程分配时间片并轮转的方式执行。每次保存当前线程执行状态并加载下一个线程执行状态的操作叫做一次上下文切换

### 死锁的发生条件
- 互斥条件：同一时刻只有一个线程占有此资源
- 请求与保持条件：一个线程被阻塞后，对已经持有的锁不会释放
- 不剥夺条件：线程已获得的资源不会被其他线程强行剥夺，直到自己用完释放
- 循环等待资源：多个线程之间循环等待资源

### 如何避免死锁
- 破坏互斥条件：无法实现
- 破坏请求与保持条件：一次性获取所有的资源
- 破坏不剥夺条件：自己获取不到资源时候，主动释放自己持有的资源
- 破坏循环等待：按照相同顺序获取资源

### wait()方法和sleep()共同点和区别
- 共同点：都可以暂停当前线程的执行
- 不同点：sleep()不会释放锁，wait()会释放锁
- wait()通常用于线程间通讯，sleep()用于暂停线程
- wait()暂停后不会自动唤醒，需要配合notify()和notifyall()方法唤醒，sleep()会自动唤醒

### 为什么调用start()而不是run()方法
- 调用start()方法才会新建一个线程，然后调用run()方法
- 调用run()方法会当作一个普通的main()方法执行，并不是多线程操作
 
 ### CPU三级缓存
 
 ### CPU缓存一致性
 
 ### JMM（java内存模型）（注意要与java内存结构区分）
 #### JMM基本概念
 - JMM是java内存模型，可以屏蔽不同操作系统的内存访问差异。
 - JMM规定所有的变量都存在主内存里，包括实例变量，静态变量。每个线程有自己的工作内存，里面会有一份主内存的拷贝副本，线程对变量的操作需要在自己的工作内存内，然后刷回主内存，不可以直接操作主内存
 
 #### JMM定义了什么
 - 原子性，一个操作或者多个操作不可以被打断，JMM只能保证基本的原子性，多个操作不能保证原子性，但是提供了monitorenter和monitorexit指令来实现，也就是synchronized锁
  - 比如int i = 1;这个只有一步操作，可以保证原子性, int j = i;这个有两步操作，先拿到i，然后赋值，不能保证原子性，i++;这是3不操作，更不能保证原子性
 - 可见性：当一个线程修改了共享变量的值，其他线程马上就可以知道。可以通过volatile来实现可见性，也可以通过synchronized（释放锁的时候把数据刷到主内存）和final实现
 - 有序性：volatile可以通过内存屏障防止指令重排序，保证有序性

#### 八种内存交互
- lock(锁定)，作用于主内存中的变量，把变量标识为线程独占的状态。
- read(读取)，作用于主内存的变量，把变量的值从主内存传输到线程的工作内存中，以便下一步的load操作使用。
- load(加载)，作用于工作内存的变量，把read操作主存的变量放入到工作内存的变量副本中。
- use(使用)，作用于工作内存的变量，把工作内存中的变量传输到执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
- assign(赋值)，作用于工作内存的变量，它把一个从执行引擎中接受到的值赋值给工作内存的变量副本中，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。
- store(存储)，作用于工作内存的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用。
- write(写入)：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。
- unlock(解锁)：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。

### volatile的作用
- 保证变量在多个线程之间的可见性，一个线程对变量操作完后，会同步回主内存，并把其他线程的变量副本失效，其他线程需要操作该变量的时候，需要重新从主内存中读取
- 防止指令重排序，保证有序性。当程序执行到volatile变量的读操作和写操作时，前面的操作的更改肯定已经进行，而且结果对后面的操作可见。后面的操作一定没有执行。重排序分为三种：编译器重排序，指令重排序，内存重排序。

### volatile可以保证线程安全么？
- 不可以，因为volatile只是实现了有序性和可见性，没有实现原子性，对于多线程下的操作来说，多个操作之间并不能保证不被其他线程执行，比如i++，这是3步操作，可以同时多个线程获取然后写入

### volatile防止指令重排序的原理
- 通过内存屏障来实现
- volatile读后面会加读读屏障，读写屏障
- volatile写前面会加写写屏障，后面会加写读屏障

### 内存屏障
- LoadLoad 屏障：对于这样的语句Load1，LoadLoad，Load2。在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。
- StoreStore屏障：对于这样的语句Store1， StoreStore， Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。
- LoadStore 屏障：对于这样的语句Load1， LoadStore，Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。
- StoreLoad 屏障：对于这样的语句Store1， StoreLoad，Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。

