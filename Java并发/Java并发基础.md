### 程序计数器为什么是私有的
- 字节码解释器通过修改程序计数器，实现代码的流程控制
- 多线程下，程序计数器记录了当前线程的执行位置，这样切换线程的时候才能知道当前线程执行到哪里了

### 虚拟机栈和本地方法栈为什么是私有的
- 因为他们存储的是局部变量表，操作数栈等，需要不被其他线程访问到

### 为什么使用多线程？多线程带来的问题
- 为了尽可能的发挥cpu和IO设备的效率。
- 问题：线程不安全，内存泄露，死锁

### 线程的几个状态
- new,线程刚被创建
- running,调用start()方法，并获得CPU资源 
- bloked, 调用同步代码后没有获取到锁进入阻塞状态
- waiting,执行wait()方法后
- timie_waiting,调用sleep等方法超过时间进入此状态
- terminated ，执行runnable的run()方法后
- https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java线程的状态.png![image](https://user-images.githubusercontent.com/55612309/110240725-36680a80-7f88-11eb-8f05-7597521d4973.png)

### 什么是上下文切换
- cpu为每个线程分配时间片并轮转的方式执行。每次保存当前线程执行状态并加载下一个线程执行状态的操作叫做一次上下文切换

### 死锁的发生条件
- 互斥条件：同一时刻只有一个线程占有此资源
- 请求与保持条件：一个线程被阻塞后，对已经持有的锁不会释放
- 不剥夺条件：线程已获得的资源不会被其他线程强行剥夺，直到自己用完释放
- 循环等待资源：多个线程之间循环等待资源

### 如何避免死锁
- 破坏互斥条件：无法实现
- 破坏请求与保持条件：一次性获取所有的资源
- 破坏不剥夺条件：自己获取不到资源时候，主动释放自己持有的资源
- 破坏循环等待：按照相同顺序获取资源

### wait()方法和sleep()共同点和区别
- 共同点：都可以暂停当前线程的执行
- 不同点：sleep()不会释放锁，wait()会释放锁
- wait()通常用于线程间通讯，sleep()用于暂停线程
- wait()暂停后不会自动唤醒，需要配合notify()和notifyall()方法唤醒，sleep()会自动唤醒

### 为什么调用start()而不是run()方法
- 调用start()方法才会新建一个线程，然后调用run()方法
- 调用run()方法会当作一个普通的main()方法执行，并不是多线程操作
 
：
