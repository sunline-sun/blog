### synchronized介绍
- synchronized解决了线程之间访问资源的同步性，保证被他修饰的代码块或者方法任意时间只有一个线程使用
- 早期Java的snchronizied使用的重量级锁，效率很低（因为是基于操作系统的Mutex lock实现的，Java线程映射到操作系统的原生线程上，切换线程时需要用户态到内核态的切换，耗费时间），Java6后做了优化

### 实际应用中是如何应用synchronized的
- 修饰实例方法：对当前实例加锁，进入同步代码块前获取实例锁
- 修饰静态方法：对当前class加锁，进入同步代码块前获取class锁，和实例锁不冲突，可以同时执行
- 修饰代码块：可以指定加锁对象，this就是对实例加锁，a.class就是对类加锁

### 构造方法可以使用synchronized么
- 不可以，构造方法本身是线程安全的

### Synchronized底层原理
- Synchronized修饰同步代码块的时候底层是通过monitorenter和monitorexit指令实现的，monitorenter指向代码开始位置，monitorexit指向代码结束位置，
  - 执行monitorenter时候，线程会获取对象监视器的持有权，如果锁的计数器是0，代表可以获取，获取之后把0改为1，如果获取不到锁，进入阻塞
  - 执行monitorexit指令，将计数器设置为0，表示锁被释放。
- Synchronized修饰方法的时候，用的是acc_synchronized标识，这个标识代表这个方法是个同步方法，JVM通过这个标识判断这个方法是否是同步方法。
- 两种修饰方式，实际都是对对象监视器monitor的获取

### 锁升级的过程
- 当只有一个线程获取锁的时候，无锁会进化为偏向锁（有偏向锁的存在是因为大部分情况只有一个线程获取锁），偏向锁不会自动释放，加锁成功后，会在锁对象的对象头中存储获取到锁的线程id，后续这个线程在需要获取锁的时候，判断线程id指向的自己，就不需要再次加锁的过程了
- 当第二个线程来获取锁的时候，判断锁对象的锁状态，如果是偏向锁，会先暂停持有锁的线程，判断此线程是否存活，如果没有存活了，把锁状态改为无锁，当前线程通过cas获取锁，如果线程还存活，证明有竞争存在，就会把偏向锁升级为轻量级锁
- 升级为轻量级锁后，两个线程通过CAS获取锁，获取到锁的线程会在自己的栈桢里创建锁记录，把锁对象的MarkDown复制到自己的锁记录里，将锁记录的owner指向锁对象，将锁对象的指针指向锁记录
- 如果持有轻量级锁的线程执行结束，需要释放锁，也是通过CAS操作把自己栈桢里的锁记录还原到锁对象的MarkDown里，如果成功，表示没有竞争，如果失败，升级为重量级锁
- 如果线程CAS获取轻量级锁的时间过长，轻量级锁也会升级为重量级锁
- 升级为重量级锁后，后面再来的线程判断锁状态为重量级锁，会直接挂起，等待锁的释放。

### 不同锁状态下的MarkDown
- 无锁状态
25bit 	4bit 	1bit(是否是偏向锁) 	2bit(锁标志位)
对象的hashCode 	对象分代年龄 	0 	01
- 偏向锁状态
23bit 	2bit 	4bit 	1bit 	2bit
线程ID 	epoch 	对象分代年龄 	1 	01
- 轻量级锁状态
30bit 	2bit
指向栈中锁记录的指针 	00
- 重量级锁状态
30bit 	2bit
指向互斥量(重量级锁)的指针 	10
