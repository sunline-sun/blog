### lock()原理
- ReentrantLock是通过Sync类来管理锁的，Sync继承了AQS抽象类，创建ReentrantLock的时候会指定使用公平锁还是非公平锁，对应的就是FairSync和NoneFairSync，这两个类继承了Sync类，这两个类重写了获取锁的方法，公平锁会按照队列顺序获取锁，非公平锁直接获取锁
- AQS就是一个同步队列，包含四个属性，头结点、尾结点、状态（是否有线程持有锁）、持有锁的线程。Node节点也有四个属性：prev、next、状态（等待获取锁还是取消还是啥的）、当前线程。获取锁其实就是修改AQS状态的过程

### lock实现步骤
- 根据是公平锁还是非公平锁进入对应实现类的加锁方法
  - 公平锁的话直接调用AQS父类的获取锁的方法
  - 非公平锁的话先试一下CAS获取锁，获取到锁的话把锁线程改为自己的线程，获取锁失败在调用AQS父类的获取锁方法
- 调用tryAcquire()获取锁的方法，公平锁和非公平锁有各自实现
  - 公平锁下先获取锁的状态
    - 如果state=0，说明现在没有线程持有锁，然后判断自己前面是否有线程等待
      - 有的话直接返回false代表获取锁失败
      - 前面没有线程等待自己会通过CAS尝试获取锁，如果获取到了，把锁线程改为自己的线程，如果获取失败，返回false代表获取锁失败
    - 判断当前持有锁的线程和自己的线程是不是同一个，是的话把state+1代表又获取一次锁，这是可重入锁的实现方式
    - 如果不符合上面两个条件，直接返回false代表获取锁失败
  - 非公平锁和公平锁步骤基本一致，只是不需要判断自己前面是否有线程等待了
- 获取锁失败后，线程会加入到阻塞队列中
  - 先把线程包装成一个Node节点，然后判断尾结点是否为空，也就是判断这个阻塞队列是否为空
    - 如果不为空的话，把包装的Node节点插入队列尾部，把AQS的尾结点指向新的Node节点
    - 如果为空的话，说明阻塞队列还是空的，就创建一个头节点，然后把新的Node节点放在这个头结点后面
- 插入队列后，
