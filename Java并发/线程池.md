### 使用线程池的好处
- 降低资源消耗，通过重复利用已创建的线程降低创建和销毁造成的消耗
- 提高响应速度，当任务到达时不需要等线程创建在执行
- 提高线程的可管理性，可以进行统一分配和监控

### 实现Runnable和实现callable的区别
- 实现Runnable接口方式不支持返回值和抛出检查异常，callable支持，所以看情况使用，不需要返回的就可以用runnable
- 工具类excutors可以实现runnable对象和callable对象的转换，Excutors.callable(runnable a)

### 执行execute()方法和submit()方法的区别
- execute()方法用于提交之后不需要有返回值的任务，提交之后就不知道线程执行情况了
- submit()方法用于提交之后需要返回值的任务，线程池会返回一个future对象，通过这个对象可以知道任务是否执行结束了，返回值是什么，也可以停止任务的执行

### Executor框架结构
- 任务（Runnable/callable）Runnable或者callable的实现类都可以被threadPoolExecutor或者SchduledThreadPoolExecutor执行
- 任务的执行（Executor）主要是通过threadPoolExecutor或者SchduledThreadPoolexecutor执行，ThreadPoolExecutor继承了AbstractExecutorService，AbstractExecutorService实现了ExecutorService接口,SchedulerThreadPoolExecutor继承了ThreadPoolExecutor类，又实现了SchedulerExecutorService，SchedulerExecutorService实现了ExecutorService接口
- 异步计算的结果（future）FutureTask是Future接口的实现类，执行任务之后线程池会返回一个Future对象，可以通过这个Future对象判断任务执行情况
![图片](https://user-images.githubusercontent.com/55612309/110796684-2f583980-82b3-11eb-96e7-ea28f5006c36.png)

### 线程池的大概使用过程
- 主线程创建Runnable或者Callable的任务对象
- ExcutorService.execute(Runnable r)方法执行任务或者ExcutorService.submit(Callable<?> task)方法执行
- 如果调用的是submit()方法，ExcutorService会返回一个Future对象
- 主线程通过FutureTask.get()或者cancel()方法等待任务执行或者取消任务执行

### ThreadPoolExecutor构造方法及参数作用
- ThreadPoolExecutor有4个构造方法，但是原理一样，只是有些参数可以使用默认值，下面是他的参数
- corePoolSize：核心线程数
- maximumPoolSize：最大线程数
- keepAliveTime：存活时间，就是线程数超过核心线程数之后，空闲线程的存活时间
- unit：时间单位
- BlockingQueue<Runnable> workQueue：任务队列，用来存储等待执行任务的队列
- ThreadFactory threadFactory 线程工厂，用来创建线程，一般默认即可
- RejectedExecutionHandler handler 拒绝策略，提交的任务过多的时候不能及时处理，可以用相应的拒绝策略

<details>
  <summary>源代码</summary>
  
  ```java
   /**
     * 用给定的初始参数创建一个新的ThreadPoolExecutor。
     */
    public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量
                              int maximumPoolSize,//线程池的最大线程数
                              long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间
                              TimeUnit unit,//时间单位
                              BlockingQueue<Runnable> workQueue,//任务队列，用来储存等待执行任务的队列
                              ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可
                              RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务
                               ) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
  ```
  
  </details>

### ThreadPoolExecutor四种拒绝策略
- 抛出异常，拒绝新任务（默认的策略）
- 自己再次调用execute方法，重试机制，会延缓新任务的加入，降低程序的性能，如果接受有一定延迟，要求任务一定要执行的可以用这种
- 直接抛弃新任务
- 抛弃最早没有执行的任务

### 创建线程池的几种方式和比较
- 通过ThreadPoolExecutor构造函数实现，也是推荐的方式，因为可以自己定义各种参数
- 通过Executor框架的工具类Executors实现，可以创建3种类型的线程池，内部其实都是调用了ThreadPoolExecutor构造方法，只是能设置的很少
  - FixedThreadPool: 允许请求的队列长度为Integer.MAX_VALUE,可能造成大量的请求堆积，造成OOM
  - SingleThreadExecotr：和FixedThreadPool一样的弊端
  - CachedThreadPool：允许创建的线程数为Integer.MAX_VALUE,可能造成大量的线程创建，造成OOM

### 线程池execute()方法
- 




